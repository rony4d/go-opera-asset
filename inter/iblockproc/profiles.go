// Package iblockproc defines the structures and logic for processing inter-block state.
// This file (profiles.go) defines the ValidatorProfiles type, which is a collection of
// validator definitions mapped by their ID. It handles the storage, deep copying, and
// deterministic serialization (RLP) of these validator profiles, ensuring that the
// validator set can be consistently encoded and decoded across the network.

package iblockproc

import (
	"io"
	"math/big"

	"github.com/Fantom-foundation/lachesis-base/inter/idx"
	"github.com/Fantom-foundation/lachesis-base/inter/pos"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/rony4d/go-opera-asset/inter/drivertype"
)

// ValidatorProfiles is a mapping of ValidatorID to their full Validator definition (Weight, PubKey).
// It serves as a lookup table for validator details within the block processing logic.
type ValidatorProfiles map[idx.ValidatorID]drivertype.Validator

// Copy creates a deep copy of the ValidatorProfiles map.
// Since the map values contain pointers (like *big.Int for Weight) and reference types (slices in PubKey),
// a shallow copy is insufficient to prevent shared state mutation. This function ensures
// a completely independent instance is returned.
func (vv ValidatorProfiles) Copy() ValidatorProfiles {
	cp := make(ValidatorProfiles, len(vv))
	for k, v := range vv {
		cpv := v
		// Deep copy the weight (big.Int is a struct with a slice inside)
		cpv.Weight = new(big.Int).Set(cpv.Weight)
		// Deep copy the public key
		cpv.PubKey = cpv.PubKey.Copy()
		cp[k] = cpv
	}
	return cp
}

// SortedArray converts the map into a slice of ValidatorAndID structs, sorted deterministically.
// The sorting logic is delegated to the 'pos' package (likely by ID or Weight).
// This is crucial for deterministic serialization because Go maps iteration order is random.
// To have a consistent hash or RLP encoding, we must convert the map to a sorted list first.
func (vv ValidatorProfiles) SortedArray() []drivertype.ValidatorAndID {
	// Use the builder to construct a validator set representation that helps with sorting
	builder := pos.NewBigBuilder()
	for id, profile := range vv {
		builder.Set(id, profile.Weight)
	}
	validators := builder.Build()

	// Get IDs in a deterministic sorted order
	sortedIds := validators.SortedIDs()

	// Construct the result array based on the sorted order
	arr := make([]drivertype.ValidatorAndID, validators.Len())
	for i, id := range sortedIds {
		arr[i] = drivertype.ValidatorAndID{
			ValidatorID: id,
			Validator:   vv[id],
		}
	}
	return arr
}

// EncodeRLP implements the rlp.Encoder interface.
// It overrides the default map serialization to ensure determinism.
// Instead of encoding the map directly (which has random order), it encodes the
// sorted array representation generated by SortedArray().
func (vv ValidatorProfiles) EncodeRLP(w io.Writer) error {
	return rlp.Encode(w, vv.SortedArray())
}

// DecodeRLP implements the rlp.Decoder interface.
// It handles deserialization by reading the data as a sorted array of ValidatorAndID,
// and then reconstructing the internal map structure from that array.
func (vv *ValidatorProfiles) DecodeRLP(s *rlp.Stream) error {
	var arr []drivertype.ValidatorAndID
	if err := s.Decode(&arr); err != nil {
		return err
	}

	*vv = make(ValidatorProfiles, len(arr))

	// Rebuild the map from the decoded array
	for _, it := range arr {
		(*vv)[it.ValidatorID] = it.Validator
	}

	return nil
}
