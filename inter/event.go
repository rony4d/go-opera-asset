/*
This file is the core definition of an "Event" in the Lachesis consensus protocol. Unlike a linear blockchain where you have Blocks, Lachesis uses a DAG (Directed Acyclic Graph) of Events.

1. Hierarchy of Types
The file uses a composition pattern to build up the Event object:
dag.Event (External): The most basic interface, defined in the lachesis-base library. It only cares about graph topology (Parents, SelfParent, Lamport time).
EventI: The application-specific interface. It adds business logic fields like GasPower, CreationTime, and PayloadHash.
EventPayloadI: Adds the actual data content: Transactions, Votes, and Proofs.

2. Struct Composition
When porting, pay attention to how the struct is composed:
Event: The header. It contains metadata but no transactions. This is used for topological ordering and consensus voting.
EventPayload: The full object. It embeds Event and adds payloadData (Transactions).
MutableEventPayload: The "Builder". Since the Event struct is immutable (caches hashes), this struct is used to set fields one by one before calling Build().

3. The "Locator" Concept
The EventLocator is a critical optimization.
In a DAG, you often need to reference events without having their full body.
The Locator summarizes an event uniquely using its Epoch, Seq (sequence number), Creator, and PayloadHash.
Important: The signature of an event is generated by signing the hash of the Locator, not the raw binary of the whole event. This allows verifying the identity of an event using only its lightweight locator.

4. Hashing Logic (CalcPayloadHash)
The PayloadHash is a digest of the content the event carries.
Version 0: Simple. It was just the Root Hash of the Transactions Merkle Tree.
Version 1+: It combines 4 things:
Transactions Hash
Misbehaviour Proofs Hash
Epoch Vote Hash
Block Vote Hash
When porting, ensure you replicate the exact hashing order in CalcPayloadHash or consensus will break.

5. ID Calculation
The function ID() in EventLocator (lines 339-343) does something specific to Lachesis:
It takes the cryptographic hash (SHA256).
It overwrites the first 4 bytes with the Epoch number.
It overwrites the next 4 bytes with the Lamport time.
Why? This allows the byte-value of the ID to be roughly sortable. If you store these IDs in a database keyed by ID, they naturally sort by Epoch and Time.

6. Separation of Data
extEventData: Metadata (Time, ForkID).
payloadData: Content (Txs, Votes).
sigData: Authentication (Signature).
This separation cleanly divides the "Graph" part of the event from the "Ethereum/State" part of the event.
*/
package inter

import (
	"crypto/sha256"

	"github.com/Fantom-foundation/lachesis-base/common/bigendian"
	"github.com/Fantom-foundation/lachesis-base/hash"
	"github.com/Fantom-foundation/lachesis-base/inter/dag"
	"github.com/Fantom-foundation/lachesis-base/inter/idx"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/ethereum/go-ethereum/trie"
)

// EventI is the abstract interface for a DAG event.
// It extends the basic dag.Event interface with chain-specific metadata
// like versioning, network IDs, timestamps, and gas metrics.
type EventI interface {
	dag.Event

	// Version returns the protocol version of the event.
	// Different versions may change how hashes are calculated or data is structured.
	Version() uint8

	// NetForkID returns the identifier for the specific network fork (e.g., testnet vs mainnet sub-forks).
	NetForkID() uint16

	// CreationTime returns the timestamp when the event was created by the validator.
	CreationTime() Timestamp

	// MedianTime returns a consensus-based timestamp, usually derived from parents' timestamps.
	MedianTime() Timestamp

	// PrevEpochHash returns the hash of the previous epoch's state, linking epochs together.
	PrevEpochHash() *hash.Hash

	// Extra returns arbitrary extra data bytes attached to the event.
	Extra() []byte

	// GasPowerLeft returns the amount of gas power remaining for the validator at this event.
	// This is used for throughput limiting / gas calculation.
	GasPowerLeft() GasPowerLeft

	// GasPowerUsed returns how much gas power this specific event consumes.
	GasPowerUsed() uint64

	// HashToSign returns the specific hash that the validator signs.
	// This is often a hash of the 'Locator' rather than the full raw event data.
	HashToSign() hash.Hash

	// Locator returns a lightweight descriptor of the event.
	Locator() EventLocator

	// Payload-related fields checks. These allow quick checks without iterating the full payload.

	// AnyTxs returns true if the event carries any transactions.
	AnyTxs() bool
	// AnyBlockVotes returns true if the event carries votes for a block (Lachesis specific).
	AnyBlockVotes() bool
	// AnyEpochVote returns true if the event carries a vote for sealing an epoch.
	AnyEpochVote() bool
	// AnyMisbehaviourProofs returns true if the event carries proofs of malicious behavior (slashing).
	AnyMisbehaviourProofs() bool

	// PayloadHash returns the merkle root or hash of the payload content (Txs, Votes, Proofs).
	PayloadHash() hash.Hash
}

// EventLocator is a lightweight structure used to identify and verify an event
// without needing the full event body (transactions, etc.).
// It contains the essential consensus fields.
type EventLocator struct {
	BaseHash    hash.Hash       // Hash of the base DAG fields (parents, etc.)
	NetForkID   uint16          // Network Fork ID
	Epoch       idx.Epoch       // The epoch this event belongs to
	Seq         idx.Event       // Sequence number of the event for this creator
	Lamport     idx.Lamport     // Lamport timestamp (logical clock)
	Creator     idx.ValidatorID // ID of the validator who created this
	PayloadHash hash.Hash       // Hash of the transactions/votes carried by the event
}

// SignedEventLocator wraps an EventLocator with its signature.
// This is often used in gossip protocols to exchange event headers quickly.
type SignedEventLocator struct {
	Locator EventLocator
	Sig     Signature
}

// AsSignedEventLocator extracts the locator and signature from a full event payload.
func AsSignedEventLocator(e EventPayloadI) SignedEventLocator {
	return SignedEventLocator{
		Locator: e.Locator(),
		Sig:     e.Sig(),
	}
}

// EventPayloadI extends EventI to include the actual data payload.
// While EventI gives metadata, EventPayloadI gives access to the transactions and votes.
type EventPayloadI interface {
	EventI
	Sig() Signature // The cryptographic signature of the creator

	Txs() types.Transactions                 // The list of EVM transactions
	EpochVote() LlrEpochVote                 // Vote to close/seal an epoch
	BlockVotes() LlrBlockVotes               // Votes for block confirmation
	MisbehaviourProofs() []MisbehaviourProof // Proofs of slashing conditions
}

// emptyPayloadHash1 is the pre-computed hash for an empty payload in version 1.
var emptyPayloadHash1 = CalcPayloadHash(&MutableEventPayload{extEventData: extEventData{version: 1}})

// EmptyPayloadHash returns the hash of an empty payload for a given protocol version.
func EmptyPayloadHash(version uint8) hash.Hash {
	if version == 0 {
		return hash.Hash(types.EmptyRootHash)
	} else {
		return emptyPayloadHash1
	}
}

// baseEvent is a wrapper around the generic DAG event implementation.
type baseEvent struct {
	dag.BaseEvent
}

// mutableBaseEvent is the mutable version of baseEvent, used during event construction.
type mutableBaseEvent struct {
	dag.MutableBaseEvent
}

// extEventData holds the extended metadata specific to this blockchain implementation
// that is not part of the generic DAG structure.
type extEventData struct {
	version       uint8
	netForkID     uint16
	creationTime  Timestamp
	medianTime    Timestamp
	prevEpochHash *hash.Hash
	gasPowerLeft  GasPowerLeft
	gasPowerUsed  uint64
	extra         []byte

	// Boolean flags to quickly check presence of data without parsing lists
	anyTxs                bool
	anyBlockVotes         bool
	anyEpochVote          bool
	anyMisbehaviourProofs bool
	payloadHash           hash.Hash
}

// sigData holds the signature of the event.
type sigData struct {
	sig Signature
}

// payloadData holds the actual content carried by the event.
type payloadData struct {
	txs                types.Transactions
	misbehaviourProofs []MisbehaviourProof
	epochVote          LlrEpochVote
	blockVotes         LlrBlockVotes
}

// Event is the immutable concrete implementation of an Event (without the full payload).
// It represents the header/metadata part of a block in a traditional blockchain.
type Event struct {
	baseEvent
	extEventData

	// cache fields (pre-calculated hashes to avoid re-hashing)
	_baseHash    *hash.Hash
	_locatorHash *hash.Hash
}

// SignedEvent is an Event that has been signed.
type SignedEvent struct {
	Event
	sigData
}

// EventPayload is the complete object: SignedEvent + the actual transactions/votes.
// This is what is transferred over the network when syncing full events.
type EventPayload struct {
	SignedEvent
	payloadData

	// cache
	_size int // Size in bytes
}

// MutableEventPayload is a builder struct used to construct a new EventPayload.
// Fields can be modified before calling Build().
type MutableEventPayload struct {
	mutableBaseEvent
	extEventData
	sigData
	payloadData
}

// HashToSign returns the hash that was signed by the validator.
// Ideally, this matches the Locator hash.
func (e *Event) HashToSign() hash.Hash {
	return *e._locatorHash
}

// asLocator creates an EventLocator struct from an EventI interface and its base hash.
func asLocator(basehash hash.Hash, e EventI) EventLocator {
	return EventLocator{
		BaseHash:    basehash,
		NetForkID:   e.NetForkID(),
		Epoch:       e.Epoch(),
		Seq:         e.Seq(),
		Lamport:     e.Lamport(),
		Creator:     e.Creator(),
		PayloadHash: e.PayloadHash(),
	}
}

// Locator returns the locator for this specific Event instance.
func (e *Event) Locator() EventLocator {
	return asLocator(*e._baseHash, e)
}

// Size returns the cached size of the event in bytes.
func (e *EventPayload) Size() int {
	return e._size
}

// Getters for extEventData to satisfy EventI interface
func (e *extEventData) Version() uint8              { return e.version }
func (e *extEventData) NetForkID() uint16           { return e.netForkID }
func (e *extEventData) CreationTime() Timestamp     { return e.creationTime }
func (e *extEventData) MedianTime() Timestamp       { return e.medianTime }
func (e *extEventData) PrevEpochHash() *hash.Hash   { return e.prevEpochHash }
func (e *extEventData) Extra() []byte               { return e.extra }
func (e *extEventData) PayloadHash() hash.Hash      { return e.payloadHash }
func (e *extEventData) AnyTxs() bool                { return e.anyTxs }
func (e *extEventData) AnyMisbehaviourProofs() bool { return e.anyMisbehaviourProofs }
func (e *extEventData) AnyEpochVote() bool          { return e.anyEpochVote }
func (e *extEventData) AnyBlockVotes() bool         { return e.anyBlockVotes }
func (e *extEventData) GasPowerLeft() GasPowerLeft  { return e.gasPowerLeft }
func (e *extEventData) GasPowerUsed() uint64        { return e.gasPowerUsed }

// Getter for sigData
func (e *sigData) Sig() Signature { return e.sig }

// Getters for payloadData
func (e *payloadData) Txs() types.Transactions                 { return e.txs }
func (e *payloadData) MisbehaviourProofs() []MisbehaviourProof { return e.misbehaviourProofs }
func (e *payloadData) BlockVotes() LlrBlockVotes               { return e.blockVotes }
func (e *payloadData) EpochVote() LlrEpochVote                 { return e.epochVote }

// CalcTxHash calculates the Merkle root of the transactions using a trie.
func CalcTxHash(txs types.Transactions) hash.Hash {
	return hash.Hash(types.DeriveSha(txs, trie.NewStackTrie(nil)))
}

// CalcReceiptsHash calculates the hash of receipts (execution results).
func CalcReceiptsHash(receipts []*types.ReceiptForStorage) hash.Hash {
	hasher := sha256.New()
	_ = rlp.Encode(hasher, receipts)
	return hash.BytesToHash(hasher.Sum(nil))
}

// CalcMisbehaviourProofsHash calculates the hash of any slashing proofs.
func CalcMisbehaviourProofsHash(mps []MisbehaviourProof) hash.Hash {
	hasher := sha256.New()
	_ = rlp.Encode(hasher, mps)
	return hash.BytesToHash(hasher.Sum(nil))
}

// CalcPayloadHash computes a deterministic hash of the event payload (Txs, Votes, Proofs).
// It handles version differences:
// Version 0: Just the Transaction Hash.
// Version >0: Hash of (TxHash, ProofsHash, EpochVoteHash, BlockVotesHash).
func CalcPayloadHash(e EventPayloadI) hash.Hash {
	if e.Version() == 0 {
		return CalcTxHash(e.Txs())
	}
	// Combine all payload component hashes into one structural hash
	return hash.Of(
		hash.Of(CalcTxHash(e.Txs()).Bytes(), CalcMisbehaviourProofsHash(e.MisbehaviourProofs()).Bytes()).Bytes(),
		hash.Of(e.EpochVote().Hash().Bytes(), e.BlockVotes().Hash().Bytes()).Bytes(),
	)
}

// Setters for MutableEventPayload (Builder pattern methods)

func (e *MutableEventPayload) SetVersion(v uint8)             { e.version = v }
func (e *MutableEventPayload) SetNetForkID(v uint16)          { e.netForkID = v }
func (e *MutableEventPayload) SetCreationTime(v Timestamp)    { e.creationTime = v }
func (e *MutableEventPayload) SetMedianTime(v Timestamp)      { e.medianTime = v }
func (e *MutableEventPayload) SetPrevEpochHash(v *hash.Hash)  { e.prevEpochHash = v }
func (e *MutableEventPayload) SetExtra(v []byte)              { e.extra = v }
func (e *MutableEventPayload) SetPayloadHash(v hash.Hash)     { e.payloadHash = v }
func (e *MutableEventPayload) SetGasPowerLeft(v GasPowerLeft) { e.gasPowerLeft = v }
func (e *MutableEventPayload) SetGasPowerUsed(v uint64)       { e.gasPowerUsed = v }
func (e *MutableEventPayload) SetSig(v Signature)             { e.sig = v }

func (e *MutableEventPayload) SetTxs(v types.Transactions) {
	e.txs = v
	e.anyTxs = len(v) != 0
}

func (e *MutableEventPayload) SetMisbehaviourProofs(v []MisbehaviourProof) {
	e.misbehaviourProofs = v
	e.anyMisbehaviourProofs = len(v) != 0
}

func (e *MutableEventPayload) SetBlockVotes(v LlrBlockVotes) {
	e.blockVotes = v
	e.anyBlockVotes = len(v.Votes) != 0
}

func (e *MutableEventPayload) SetEpochVote(v LlrEpochVote) {
	e.epochVote = v
	e.anyEpochVote = v.Epoch != 0 && v.Vote != hash.Zero
}

// calcEventID converts a hash to a fixed-size byte array used as an ID.
func calcEventID(h hash.Hash) (id [24]byte) {
	copy(id[:], h[:24])
	return id
}

// calcEventHashes computes the two main hashes defining an event:
// 1. base: Hash of the serialized event data itself.
// 2. locator: The hash that is actually signed (includes BaseHash + metadata).
func calcEventHashes(ser []byte, e EventI) (locator hash.Hash, base hash.Hash) {
	base = hash.Of(ser)
	if e.Version() < 1 {
		return base, base
	}
	return asLocator(base, e).HashToSign(), base
}

// calcHashes is a helper for the mutable payload to calculate its hashes before building.
func (e *MutableEventPayload) calcHashes() (locator hash.Hash, base hash.Hash) {
	b, _ := e.immutable().Event.MarshalBinary()
	return calcEventHashes(b, e)
}

// size calculates the size of the encoded event.
func (e *MutableEventPayload) size() int {
	b, err := e.immutable().MarshalBinary()
	if err != nil {
		panic("can't encode: " + err.Error())
	}
	return len(b)
}

// HashToSign implementation for MutableEventPayload to satisfy interfaces during construction.
func (e *MutableEventPayload) HashToSign() hash.Hash {
	h, _ := e.calcHashes()
	return h
}

func (e *MutableEventPayload) Locator() EventLocator {
	_, baseHash := e.calcHashes()
	return asLocator(baseHash, e)
}

func (e *MutableEventPayload) Size() int {
	return e.size()
}

// build constructs the final immutable EventPayload from the mutable state.
func (e *MutableEventPayload) build(locatorHash hash.Hash, baseHash hash.Hash, size int) *EventPayload {
	return &EventPayload{
		SignedEvent: SignedEvent{
			Event: Event{
				// Initialize the base DAG event with the calculated ID
				baseEvent:    baseEvent{*e.MutableBaseEvent.Build(calcEventID(locatorHash))},
				extEventData: e.extEventData,
				// Store cached hashes
				_baseHash:    &baseHash,
				_locatorHash: &locatorHash,
			},
			sigData: e.sigData,
		},
		payloadData: e.payloadData,
		_size:       size,
	}
}

// immutable creates a temporary immutable version (used for serialization/hashing during build).
func (e *MutableEventPayload) immutable() *EventPayload {
	return e.build(hash.Hash{}, hash.Hash{}, 0)
}

// Build finalizes the MutableEventPayload into an immutable EventPayload.
// This calculates all hashes and serializes the object to determine its size.
func (e *MutableEventPayload) Build() *EventPayload {
	locatorHash, baseHash := e.calcHashes()
	payloadSer, _ := e.immutable().MarshalBinary()
	return e.build(locatorHash, baseHash, len(payloadSer))
}

// HashToSign computes the unique identifier that is signed by the validator.
// It combines the BaseHash (parents, etc.) with epoch, sequence, and payload hash.
func (l EventLocator) HashToSign() hash.Hash {
	return hash.Of(
		l.BaseHash.Bytes(),
		bigendian.Uint16ToBytes(l.NetForkID),
		l.Epoch.Bytes(),
		l.Seq.Bytes(),
		l.Lamport.Bytes(),
		l.Creator.Bytes(),
		l.PayloadHash.Bytes(),
	)
}

// ID returns a shortened identifier (EventID) based on the full HashToSign.
func (l EventLocator) ID() hash.Event {
	h := l.HashToSign()
	// Embed Epoch and Lamport time into the ID for quick sorting/filtering
	copy(h[0:4], l.Epoch.Bytes())
	copy(h[4:8], l.Lamport.Bytes())
	return hash.Event(h)
}
